# -*- coding: utf-8 -*-
"""Membangun ML Model

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11OvGI33TD3ze73veKkOF5bGBTrfr5J9q

# Membangun ML Model dengan **Regresi**

## Cara melihat Data pada **Regresi**

dibawah ini berfungsi untuk melakukan import beberapa modul atau library pada Python dan membaca data dalam format CSV.
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from sklearn import linear_model

df = pd.read_csv("/content/drive/MyDrive/workshop-python/honeyproduction.csv")

"""`df.head()` adalah sebuah perintah pada pandas DataFrame yang digunakan untuk menampilkan sebagian awal atau sejumlah baris teratas dari sebuah DataFrame."""

df.head()

"""Kode dibawah digunakan untuk mengelompokkan data pada kolom `totalprod` berdasarkan tahun pada DataFrame `df`, menghitung rata-rata dari kolom `totalprod` pada setiap tahun, dan menyimpan hasilnya pada DataFrame `prod_per_year`. Hasil DataFrame `prod_per_year` kemudian dicetak menggunakan fungsi `print()`."""

prod_per_year = df.groupby("year").totalprod.mean().reset_index()
print(prod_per_year)

"""Kode dibawah merupakan bagian dari persiapan data untuk dilakukan regresi linear sederhana menggunakan library scikit-learn pada Python.

Pertama, kita menyimpan data tahun (`year`) yang ada pada DataFrame `prod_per_year` pada variabel `X`. Karena `X` masih berupa satu dimensi, maka kita perlu mengubah bentuknya agar bisa digunakan pada fungsi regresi linear sederhana. Kita gunakan method `values.reshape()` untuk mengubah bentuk data `X` menjadi dua dimensi dengan jumlah baris yang tidak diketahui (`-1`) dan jumlah kolom sebanyak satu (`1`) dengan memanggil `reshape(-1, 1)` pada variabel `X`.

Selanjutnya, kita menyimpan data produksi madu (`totalprod`) yang ada pada DataFrame `prod_per_year` pada variabel `Y`.

Dengan begitu, kita telah mempersiapkan data yang akan digunakan pada fungsi regresi linear sederhana untuk memprediksi produksi madu pada tahun-tahun berikutnya berdasarkan data produksi madu pada tahun-tahun sebelumnya.
"""

X = prod_per_year['year']
X = X.values.reshape(-1, 1)

Y = prod_per_year['totalprod']

"""Kode dibawah digunakan untuk memvisualisasikan data produksi madu (`Y`) terhadap tahun (`X`) dalam bentuk scatter plot menggunakan modul `matplotlib.pyplot` pada Python.

Fungsi scatter() pada `matplotlib.pyplot` digunakan untuk membuat scatter plot dengan sumbu `X` sebagai sumbu horizontal dan sumbu `Y` sebagai sumbu vertikal. Pada kode tersebut, kita memasukkan `X` sebagai sumbu horizontal dan `Y` sebagai sumbu vertikal.

Setelah itu, fungsi `show()` pada `matplotlib.pyplot` digunakan untuk menampilkan plot yang sudah dibuat. Sehingga hasil plot scatter plot dari data produksi madu terhadap tahun dapat dilihat pada layar.
"""

plt.scatter(X, Y)
plt.show()

"""## Cara membuat **Regresi**

Kode dibawah digunakan untuk membuat objek regresi linear sederhana menggunakan library scikit-learn pada Python, yang akan digunakan untuk memprediksi produksi madu pada tahun-tahun berikutnya berdasarkan data produksi madu pada tahun-tahun sebelumnya.

Pertama, kita membuat objek regresi linear sederhana menggunakan class `LinearRegression()` pada library scikit-learn dan menyimpannya pada variabel `regr`.

Kemudian, kita menampilkan hasil fitting model regresi linear sederhana dengan memasukkan data tahun (`X`) dan data produksi madu (`Y`) menggunakan fungsi `fit()` pada objek regr. Fungsi `fit()` digunakan untuk mempelajari hubungan linier antara variabel independen (`X`) dan variabel dependen (`Y`) pada data training yang diberikan.

Selanjutnya, kita mencetak nilai koefisien (`coef_`) dan nilai intercept (`intercept_`) dari model regresi linear sederhana menggunakan fungsi `print()`. Nilai koefisien (`coef_`) akan menampilkan kemiringan garis regresi linear sederhana dan nilai intercept (`intercept_`) akan menampilkan nilai dari titik potong garis regresi linear sederhana dengan sumbu Y.
"""

regr = linear_model.LinearRegression()
print(regr.fit(X, Y))
print(regr.coef_[0])
print(regr.intercept_)

"""Kode dibawah digunakan untuk memprediksi produksi madu pada setiap tahun pada DataFrame `prod_per_year` menggunakan model regresi linear sederhana yang telah dibuat sebelumnya.

Pertama, kita menggunakan method `predict()` pada objek `regr` untuk memprediksi produksi madu pada setiap tahun yang ada dalam DataFrame `prod_per_year`. Argumen yang dimasukkan ke dalam method `predict()` adalah data tahun (`X`), karena model regresi linear sederhana yang telah dibuat menggunakan data tahun sebagai variabel independen.

Kemudian, kita mencetak hasil prediksi tersebut menggunakan fungsi `print()` dan variabel `y_predict`. Variabel `y_predict` akan menampilkan nilai prediksi produksi madu pada setiap tahun yang ada pada DataFrame `prod_per_year`.
"""

y_predict = regr.predict(X)
print(y_predict)

"""Kode dibawah digunakan untuk memvisualisasikan hasil prediksi produksi madu pada setiap tahun yang telah dilakukan sebelumnya dengan menggunakan model regresi linear sederhana.

Pertama, fungsi `scatter()` pada `matplotlib.pyplot` digunakan untuk membuat scatter plot dengan sumbu `X` sebagai sumbu horizontal dan sumbu `Y` sebagai sumbu vertikal dari data produksi madu (`Y`) terhadap tahun (`X`).

Kemudian, fungsi `plot()` pada `matplotlib.pyplot` digunakan untuk menambahkan garis regresi linear sederhana pada scatter plot tersebut. Fungsi `plot()` membutuhkan dua argumen, yaitu data tahun (`X`) sebagai sumbu horizontal dan hasil prediksi produksi madu (`y_predict`) sebagai sumbu vertikal.

Terakhir, fungsi `show()` pada `matplotlib.pyplot` digunakan untuk menampilkan plot yang sudah dibuat. Sehingga hasil plot scatter plot dari data produksi madu terhadap tahun yang telah diprediksi menggunakan model regresi linear sederhana dapat dilihat pada layar.
"""

plt.scatter(X, Y)
plt.plot(X, y_predict)
plt.show()

"""## Memprediksi penunuran madu dengan **Regresi**

Kode dibawah digunakan untuk mempersiapkan data tahun-tahun berikutnya untuk dilakukan prediksi produksi madu menggunakan model regresi linear sederhana yang telah dibuat sebelumnya.

Pertama, kita menggunakan modul `numpy` untuk membuat array yang berisi data tahun dari tahun 2013 hingga 2050. Fungsi `range()` digunakan untuk membuat deret angka dari 2013 hingga 2049, yang kemudian diubah menjadi array menggunakan fungsi `np.array()`.

Selanjutnya, kita menggunakan method `reshape()` pada array `X_future` untuk mengubah bentuknya menjadi dua dimensi dengan jumlah baris yang tidak diketahui (`-1`) dan jumlah kolom sebanyak satu (`1`). Hal ini dilakukan karena model regresi linear sederhana yang telah dibuat hanya dapat digunakan dengan data yang berbentuk dua dimensi.
"""

X_future = np.array(range(2013, 2050))
X_future = X_future.reshape(-1, 1)

"""Kode dibawah digunakan untuk memvisualisasikan hasil prediksi produksi madu pada tahun-tahun berikutnya menggunakan model regresi linear sederhana yang telah dibuat sebelumnya.

Pertama, kita menggunakan method `predict()` pada objek `regr` untuk memprediksi produksi madu pada tahun-tahun berikutnya yang telah dipersiapkan sebelumnya (`X_future`). Hasil prediksi tersebut disimpan pada variabel `future_predict`.

Selanjutnya, kita menggunakan fungsi `scatter()` pada `matplotlib.pyplot` untuk membuat scatter plot dari data produksi madu (`Y`) terhadap tahun (`X`) seperti pada kode sebelumnya.

Kemudian, kita menambahkan garis regresi linear sederhana pada scatter plot tersebut menggunakan fungsi `plot()` dan memasukkan data tahun (`X`) sebagai sumbu horizontal dan hasil prediksi produksi madu (`y_predict`) sebagai sumbu vertikal.

Terakhir, kita menambahkan garis hasil prediksi produksi madu pada tahun-tahun berikutnya menggunakan fungsi `plot()` dan memasukkan data tahun-tahun berikutnya (`X_future`) sebagai sumbu horizontal dan hasil prediksi produksi madu pada tahun-tahun berikutnya (`future_predict`) sebagai sumbu vertikal.
"""

future_predict = regr.predict(X_future)
plt.scatter(X, Y)
plt.plot(X, y_predict)
plt.plot(X_future, future_predict)

"""# Membangun ML Model dengan **Klasifikasi**

## Cara melihat Data pada **Klasifikasi**

Kode ini hanya memuat dataset kanker payudara dan mencetak informasi tentang fitur-fiturnya.

`from sklearn.datasets import load_breast_cancer`: Mengimpor fungsi `load_breast_cancer` dari modul `sklearn.datasets`. Fungsi ini digunakan untuk memuat dataset kanker payudara yang disertakan dalam scikit-learn.

`from sklearn.model_selection import train_test_split`: Mengimpor fungsi `train_test_split` dari modul `sklearn.model_selection`. Fungsi ini digunakan untuk membagi dataset menjadi dua bagian, yaitu data latihan dan data uji.

`from sklearn.neighbors import KNeighborsClassifier`: Mengimpor kelas `KNeighborsClassifier` dari modul `sklearn.neighbors`. Ini adalah algoritma k-Nearest Neighbors yang digunakan untuk klasifikasi dalam machine learning.

`import matplotlib.pyplot as plt`: Mengimpor modul `pyplot` dari pustaka `matplotlib` dengan alias `plt`. `matplotlib` digunakan untuk membuat visualisasi data dalam bentuk grafik.

`breast_cancer_data = load_breast_cancer()`: Memuat dataset kanker payudara dan menyimpannya dalam variabel `breast_cancer_data`.

`print(breast_cancer_data.data[0])`: Mencetak vektor fitur dari sampel pertama dalam dataset kanker payudara. Vektor ini berisi nilai-nilai fitur yang digunakan untuk menggambarkan setiap sampel dalam dataset.

`print(breast_cancer_data.feature_names)`: Mencetak nama-nama fitur dalam dataset kanker payudara. Nama-nama ini memberikan informasi tentang arti dari masing-masing fitur dalam vektor fitur.
"""

from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split 
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt

breast_cancer_data = load_breast_cancer()
print(breast_cancer_data.data[0])
print(breast_cancer_data.feature_names)

"""Kode ini mencetak informasi tentang target (label) dalam dataset kanker payudara.

`print(breast_cancer_data.target)`: Mencetak array target (label) dari dataset kanker payudara. Array ini berisi label kelas (0 atau 1) untuk setiap sampel dalam dataset. Dalam konteks kanker payudara, label ini biasanya merepresentasikan diagnosis, di mana 0 berarti "malignant" (ganas) dan 1 berarti "benign" (jinak).

`print(breast_cancer_data.target_names)`: Mencetak nama-nama target dalam dataset kanker payudara. Nama-nama ini memberikan informasi tentang arti dari masing-masing label kelas dalam array target. Dalam kasus ini, target_names akan berisi array `['malignant' 'benign']`, yang menunjukkan bahwa 0 merepresentasikan "malignant" (ganas) dan 1 merepresentasikan "benign" (jinak).

Dengan mencetak breast_cancer_data.target dan breast_cancer_data.target_names, Anda dapat melihat hubungan antara label numerik dalam array target dan interpretasi diagnostik yang sesuai untuk setiap label.

Dengan mencetak `breast_cancer_data.target` dan `breast_cancer_data.target_names`, Anda dapat melihat hubungan antara label numerik dalam array target dan interpretasi diagnostik yang sesuai untuk setiap label.
"""

print(breast_cancer_data.target)
print(breast_cancer_data.target_names)

"""## membelah data menjadi latihan dan validasi untuk **Klasifikasi**

Kode ini menggunakan fungsi `train_test_split` dari modul `sklearn.model_selection` untuk membagi dataset kanker payudara menjadi data latihan dan data validasi. Berikut penjelasan setiap bagian kode:

`training_data, validation_data, training_labels, validation_labels =`: Mendefinisikan empat variabel untuk menyimpan data dan label yang dihasilkan dari pemisahan dataset. `training_data` dan `training_labels` akan berisi data dan label untuk latihan, sedangkan `validation_data` dan `validation_labels` akan berisi data dan label untuk validasi.

`train_test_split(`: Memanggil fungsi `train_test_split` untuk memisahkan dataset.

`breast_cancer_data.data,`: Argumen pertama adalah fitur dari dataset kanker payudara yang akan digunakan dalam proses pembelajaran dan validasi.

`breast_cancer_data.target,`: Argumen kedua adalah target (label) dari dataset kanker payudara yang sesuai dengan fitur yang diberikan sebelumnya.

`test_size = 0.2,`: Argumen ketiga adalah `test_size`, yang menentukan proporsi data yang akan digunakan untuk validasi. Dalam hal ini, 20% dari dataset akan digunakan untuk validasi dan sisanya (80%) untuk latihan.

`random_state = 80`: Argumen keempat adalah `random_state`, yang merupakan bilangan bulat yang digunakan sebagai seed oleh random number generator. Mengatur `random_state` ke nilai tertentu (mis. 80) memastikan bahwa pemisahan dataset akan menghasilkan hasil yang konsisten setiap kali kode dijalankan. Ini berguna saat Anda ingin membandingkan hasil dari berbagai percobaan.

Setelah menjalankan kode ini, Anda akan memiliki data latihan dan data validasi yang siap digunakan untuk melatih dan menguji model machine learning, seperti k-Nearest Neighbors.
"""

training_data, validation_data, training_labels, validation_labels = train_test_split(
    breast_cancer_data.data,
    breast_cancer_data.target,
    test_size = 0.2,
    random_state = 80
)

"""Kode ini mencetak jumlah sampel yang ada dalam `training_data` dan jumlah label yang ada dalam `training_labels` dan dengan mencetak panjang `training_data` dan `training_labels`, dapat memastikan bahwa Anda memiliki jumlah data dan label yang sesuai untuk melatih model machine learning Anda. Berikut penjelasan setiap baris kode:

`print(len(training_data))`: Mencetak panjang (jumlah sampel) dari `training_data`, yang merupakan data latihan yang dihasilkan dari pemisahan dataset menggunakan fungsi `train_test_split`. Panjang ini akan menjadi 80% dari jumlah sampel dataset asli, karena kita menetapkan `test_size = 0.2` saat memanggil `train_test_split`.

`print(len(training_labels))`: Mencetak panjang (jumlah label) dari `training_labels`, yang merupakan label latihan yang dihasilkan dari pemisahan dataset menggunakan fungsi `train_test_split`. Panjang ini akan sama dengan panjang `training_data`, karena setiap sampel dalam `training_data` akan memiliki label yang sesuai dalam `training_labels`.
"""

print(len(training_data))
print(len(training_labels))

"""## Menjalankan **Klasifikasi**

Kode ini menggunakan algoritma k-Nearest Neighbors (KNN) untuk melatih model klasifikasi pada `training_data` dan mengevaluasi akurasi model pada `validation_data` dengan jumlah tetangga yang bervariasi dari 1 hingga 100. Berikut penjelasan setiap bagian kode:

`accuracies = []`: Membuat list kosong bernama `accuracies` untuk menyimpan nilai akurasi model untuk setiap jumlah tetangga (i) dalam KNN.

`for i in range(1, 101)`: Membuat loop for yang akan berulang 100 kali dengan variabel iterator `i` yang bernilai dari 1 hingga 100 (inklusif).

`classifier = KNeighborsClassifier(n_neighbors = i)`: Membuat instance kelas `KNeighborsClassifier` dengan jumlah tetangga (k) yang ditentukan oleh variabel iterator `i`. Ini akan menciptakan model KNN dengan jumlah tetangga yang bervariasi dari 1 hingga 100.

`classifier.fit(training_data, training_labels)`: Melatih model KNN pada `training_data` dengan label yang sesuai dari `training_labels`.

`print(classifier.score(validation_data, validation_labels))`: Mencetak skor akurasi model KNN pada `validation_data` dengan label yang sesuai dari `validation_labels`. Akurasi dihitung sebagai rasio jumlah prediksi yang benar terhadap jumlah total prediksi.

`accuracies.append(classifier.score(validation_data, validation_labels))`: Menambahkan skor akurasi model KNN pada `validation_data` ke list `accuracies`. Ini akan membuat list yang berisi akurasi model untuk setiap nilai k dari 1 hingga 100.

`i_list = range(1,101)`: Membuat list `i_list` yang berisi angka dari 1 hingga 100 (inklusif). List ini dapat digunakan nanti untuk memetakan nilai akurasi ke nilai k yang sesuai.

`print(accuracies)`: Mencetak list `accuracies` yang berisi akurasi model KNN untuk setiap jumlah tetangga (k) dari 1 hingga 100.

Dengan menjalankan kode ini, Anda akan melihat bagaimana akurasi model KNN berubah dengan variasi jumlah tetangga. Anda dapat memilih jumlah tetangga yang menghasilkan akurasi tertinggi dan menggunakan model tersebut untuk prediksi lebih lanjut.
"""

accuracies = []
for i in range(1, 101):
  classifier = KNeighborsClassifier(n_neighbors = i)
  classifier.fit(training_data, training_labels)
  print(classifier.score(validation_data, validation_labels))
  accuracies.append(classifier.score(validation_data,validation_labels))

i_list = range(1,101)
print(accuracies)

"""## hasil dalam bentuk graphiknya

Kode ini menggunakan `matplotlib.pyplot` (dengan alias `plt`) untuk membuat grafik yang menampilkan hubungan antara jumlah tetangga (k) dalam algoritma KNN dan akurasi validasi yang dihasilkan. Berikut penjelasan setiap baris kode:

`plt.plot(i_list, accuracies)`: Membuat plot dengan sumbu x dari i_list (jumlah tetangga dalam KNN) dan sumbu y dari accuracies (akurasi validasi yang dihasilkan untuk setiap jumlah tetangga).

`plt.xlabel("i")`: Memberikan label "i" untuk sumbu x, yang merepresentasikan jumlah tetangga dalam KNN.

`plt.ylabel("Validation Accuracy")`: Memberikan label "Validation Accuracy" untuk sumbu y, yang merepresentasikan akurasi validasi yang dihasilkan untuk setiap jumlah tetangga dalam KNN.

`plt.title("Breast Cancer Classifier Accuracy")`: Memberikan judul "Breast Cancer Classifier Accuracy" untuk grafik yang menunjukkan hubungan antara jumlah tetangga dalam KNN dan akurasi validasi.

`plt.show()`: Menampilkan grafik yang telah dibuat. Fungsi ini akan membuka jendela visualisasi baru (atau menampilkan grafik dalam output notebook jika menggunakan Jupyter Notebook) yang menampilkan grafik yang dihasilkan.

Dengan menjalankan kode ini, Anda akan melihat grafik yang menggambarkan hubungan antara jumlah tetangga dalam algoritma KNN dan akurasi validasi yang dihasilkan. Grafik ini dapat membantu Anda memilih jumlah tetangga yang optimal untuk mencapai kinerja terbaik dalam klasifikasi kanker payudara.
"""

plt.plot(i_list, accuracies)
plt.xlabel("i")
plt.ylabel("Validation Accuracy")
plt.title("Breast Cancer Classifier Accuracy")
plt.show()